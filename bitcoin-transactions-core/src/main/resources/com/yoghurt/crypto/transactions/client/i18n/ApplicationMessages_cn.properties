title = 区块链阅读器
applicationVersion = v0.4 - 德耳塔 - 十一月 2019
applicationLookupFieldPlaceHolder = 插入任意字符、按回车键
applicationContributionText = 捐赠 / 贡献
startupGeneral = 一般导航
startupLastBlock = 最后区块
addressPlaceTitle = 地址
addressPlaceBase58CheckTitle = BASE58CHECK 分解
addressPlaceFinance = 金融
addressPlaceQRCode = 二维码
addressHash160 = 哈希160:
addressChecksum = 检查和
addressVersion = 版本：
addressAddress = 地址：
addressAddressHex = 地址（十六进制）：
addressValidFormat = 合法格式：
addressMalformedText = 告警：本地址错误。细节如下：
addressAdvertisedChecksum = 嵌入的检查和：
addressComputedChecksum = 计算的检查和：
addressMalformedWarning = 请勿发送钱到本地址！检查打字错误！
addressOutpointSpent = 花费：
addressNumberOfTransactions = # 交易：
addressBalance = 余额：
transactionPlaceTitle =  交易
transactionPlaceTitleInformation = 交易哈希
transactionPlaceTitleContext = 交易信息
transactionPlaceTitleExtraInformation = 区块链中的信息
transactionPlaceTitleTransactionInputs = 交易输入
transactionPlaceTitleTransactionOutputs = 交易输出
transactionPlaceTitleMiscellaneousInformation = 混合信息
transactionPlaceTitleError = 错误
transactionPlaceTitleRawHex = 十六进制原始交易
transactionPlaceParseError = 当分析交易时发生错误，您所看到的以下内容是在我们不能理解之前尽最大努力解析出的数据。
transactionWeight = 权重（字节）：
transactionWeightContext = 交易权重定义为：基础交易的大小*3+总交易大小
transactionVSize = 虚拟大小（字节）：
transactionVSizeContext = 虚拟交易大小定义为：交易权重/4 （向上取整）。
transactionBaseSize = 基础大小（字节）：
transactionBaseSizeContext = 基础交易大小为交易剥离除掉见证信息后交易的序列化。
transactionTotalSize = 总大小（字节）：
transactionTotalSizeContext = 总交易大小为按照BIP144描述的交易字节序列化大小，包括基础数据和见证数据。
blockPlaceTitle = 区块
blockPlaceTitleInformation = 区块哈希
blockPlaceTitleCoinbase = 基础交易哈希
blockPlaceTitleExtraInformation = 区块链中的信息
blockPlaceTitleBlockHeaders = 块头部
blockPlaceTitleRawBlockHex = 原始块头部的十六进制
blockPlaceTitleRawCoinbaseHex = 原始基础交易的十六进制
blockPlaceTitleTransactionList = 交易列表
minePlaceTitleMiningSimulator = 挖矿模拟
minePlaceTitleModifyHeaders = 修改头部
minePlaceTitleMineHeaders = 原始头部的十六进制
minePlaceTitleCoinbase = 基础交易
minePlaceTitleBlockHash = 计算块哈希
minePlaceTitleBlockHeaders = 块头部
transactionId = 交易ID：
transactionIdContext = 交易哈希
witnessIdContext = 见证哈希
transactionPreviousTransactionId = 前一个交易：
transactionOutpointIndex = 索引：
transactionScriptSig = 脚本签名：
transactionScriptPubKey = 脚本公钥：
transactionCoinbaseInput = ASCII说明：
transactionSegwitEnabled = 隔离见证激活：
transactionScriptViewer = 在脚本浏览器查看
transactionSequence = 序列：
transactionAmount = 数量：
transactionState = 状态：
transactionTime = 时间：
transactionVersion = 格式版本：
transactionLockTime = 锁定时间：
transactionOutputAddress = 发送地址：
transactionPlaceBlockchainExistenceLoading = 检查是否存在区块链中...
transactionPlaceBlockchainExistenceNotFound = 本交易不存在区块链中并且不在未确认的交易池中。
blockHeight = 块高度：
blockHash = 块哈希：
blockConfirmations = 确认：
blockVersion = 版本：
blockPreviousBlock = 前一块：
blockMerkleRoot = Merkle 根：
blockTime = 时间戳
blockBits = 难度：
blockBitsTargetExplain = 块哈希必须等于或者小于本数字，‘目标’，有效。
blockNonce = 当前值：
blockDepth = 块深度：
blockNumTransactions = # 交易：
blockNextBlock = 下一块：
blockWeight = 权重（千字节）：
blockWeightContext = 块权重定义为：基础大小*3 + 总大小。
blockVirtualSize = 虚拟大小（千字节）：
blockVirtualSizeContext = 虚拟大小定义为：能被预见证隔离规则解释的块大小，一般也叫有效块大小。
blockBaseSize = 基础大小（千字节）：
blockBaseSizeContext = 基础大小是尚未升级站点看到的包括了原始交易序列化不包含见证相关数据块字节大小。
blockTotalSize = 总大小（千字节）：
blockTotalSizeContext = 总交易大小为按照BIP144描述的交易字节序列化大小，包括基础数据和见证数据。
blockPlaceBlockchainExistenceLoading = 检查是否存在区块链中...
blockPlaceBlockchainExistenceNotFound = 区块不在区块链中。
scriptPlaceTitleScriptViewer = 脚本查看器
scriptPlaceTitleOutpointViewer = 输出点信息
scriptPlaceOutpointHash = 交易哈希：
scriptPlaceTitleScripts = 脚本
scriptPlaceExecutionResult = 最终执行结果
scriptPlaceExecutionResultSuccess = 执行脚本过程中，没有失败被触发，并且栈顶值为真（非零）。给定输入的交易输出可以被使用。注意：脚本解释器没有运行隔离见证（BIP141）或者 P2SH （BIP16）脚本，所以结果也许不能代表实际。
scriptPlaceExecutionResultFailureTriggered = 执行脚本过程中，失败被触发。给定输入的交易输出不能被使用。
scriptPlaceExecutionResultFailureResult = 执行脚本过程中，没有失败被触发，但是栈的结果是零或者空。给定输入的交易输出不能被使用。
scriptPlaceFullScript = 全脚本：
scriptPlaceScriptSigRawHex = 原始十六进制数据中的脚本签名
scriptPlaceScriptPubKeyRawHex =  原始十六进制数据中的脚本公钥
scriptPlaceStepByStep = 按步脚本执行
scriptOperation = 指令：
scriptOperationDescriptionLabel = 描述：
scriptResult = 结果：
scriptRemainingScript = Left-over 脚本：
scriptResultStack = 结果栈：
scriptExecutionStep = 执行步骤 {0}
configPlaceTitle = 配置
configPlaceCreatePasswordText = 您还没有设置应用的密码。请输入密码然后记住它。后续的配置修改，您将需要它（尽管您仅仅配置一次）<br><br>如果您忘记密码，您需要手工重置（删除）它。它的哈希值存在文件''yoghurt.conf''里<br/><br/>服务器永远不存储文本密码，客户端哈希然后在线上发送。
configPasswordPlaceHolder = 密码
configPasswordRepeatPlaceHolder = 密码确认
configPasswordConfirm = 设置密码
configPasswordLogin = 登录。
configPlaceInputPasswordText = 输入你的密码。
configBlockchainHook = 连接器：
configSubmitSettings = 保存设置
configMiscellaneousSettingsTitle = 一般设置
configBlockchainHookTitle = 区块链源设置
configConnectorOption = 未知（不支持）
configConnectorOption[NODE] = 比特币核心节点
configNodeHost = 主机（可能localhost）
configNodePort = 端口（可能8332）
configNodeRpcUser = 远程进程调用用户名
configNodeRpcPass = 远程进程调用密码
configTitlePlaceHolder = 应用标题
configSubTitlePlaceHolder = 应用子标题
configContributeAddressPlaceHolder = 赞助地址
configTitles = 应用文本
configContribution = 节点贡献

contributePlaceTitle = 贡献给本项目
contributePlaceText = <p>本项目使每一个人可以在全节点之上运行开源区块浏览器。它是由志愿者为热爱者建立的免费软件。<p><p>非常感激给本项目的贡献，进一步的开发或者独立主持事件。</p><p>本项目的GitHub库可以在<a href="https://github.com/JornC/bitcoin-transaction-explorer">这里</a>找到，假如你想开发，测试或者其他想法，请在发消息给GitHub上发消息。</p><p>本项目的捐赠可以使用以下地址：{0}</p>
contributePlaceNodeTitle = 捐赠给本节点
contributePlaceNodeText = <p>本节点捐赠地址：{0}</p>

jsonPlaceTitle = JSON 应答

#Script operations
scriptOperationDescription = 未知操作

scriptOperationDescription[OP_FALSE] = 空字节数组压栈。
scriptOperationDescription[OP_PUSHDATA] = 数据压栈。
scriptOperationDescription[OP_PUSHDATA1] = 一字节数据压栈。
scriptOperationDescription[OP_PUSHDATA2] = 二字节数据压栈。
scriptOperationDescription[OP_PUSHDATA4] = 四字节数据压栈。
scriptOperationDescription[OP_1NEGATE] = 数字-1压栈。
scriptOperationDescription[OP_TRUE] = 数字1压栈。
scriptOperationDescription[OP_2] = 数字2压栈。
scriptOperationDescription[OP_3] = 数字3压栈。
scriptOperationDescription[OP_4] = 数字4压栈。
scriptOperationDescription[OP_5] = 数字5压栈。
scriptOperationDescription[OP_6] = 数字6压栈。
scriptOperationDescription[OP_7] = 数字7压栈。
scriptOperationDescription[OP_8] = 数字8压栈。
scriptOperationDescription[OP_9] = 数字9压栈。
scriptOperationDescription[OP_10] = 数字10压栈。
scriptOperationDescription[OP_11] = 数字11压栈。
scriptOperationDescription[OP_12] = 数字12压栈。
scriptOperationDescription[OP_13] = 数字13压栈。
scriptOperationDescription[OP_14] = 数字14压栈。
scriptOperationDescription[OP_15] = 数字15压栈。
scriptOperationDescription[OP_16] = 数字16压栈。

# Flow control
scriptOperationDescription[OP_NOP] = 无操作
scriptOperationDescription[OP_IF] = 如果栈顶值不是零，执行语句。弹出栈顶值。
scriptOperationDescription[OP_NOTIF] = 如果栈顶值是零，执行语句。弹出栈顶值。
scriptOperationDescription[OP_ELSE] = 如果前述的OP_IF、OP_NOTIF或OP_ELSE没有执行，然后这些语句，否则如果前述的OP_IF、OP_NOTIF或OP_ELSE执行了，这些语句没有
scriptOperationDescription[OP_ENDIF] = if/else 块结束。所有块必须结束，或者交易是无效的。OP_ENDIF 不带 OP_IF 同样是无效的。
scriptOperationDescription[OP_VERIFY] = 如果栈顶值不是真，则标记交易是无效的。
scriptOperationDescription[OP_RETURN] = 标记交易是有效的。

# Stack
scriptOperationDescription[OP_TOALTSTACK] = 压栈顶项目到alt栈。从main栈删除。
scriptOperationDescription[OP_FROMALTSTACK] = 压栈顶项目到main栈。从alt栈删除。
scriptOperationDescription[OP_IFDUP] = 如果栈顶值不是零，复制它。
scriptOperationDescription[OP_DEPTH] = 压多个栈项目到栈。
scriptOperationDescription[OP_DROP] = 删除栈顶项目。
scriptOperationDescription[OP_DUP] = 复制栈顶项目。
scriptOperationDescription[OP_NIP] = 删除栈顶倒数第二个项目。
scriptOperationDescription[OP_OVER] = 复制栈顶倒数第二个项目。
scriptOperationDescription[OP_PICK] = 拷贝栈顶倒数第n个项目到栈顶。
scriptOperationDescription[OP_ROLL] = 移动栈顶倒数第n个项目到栈顶。
scriptOperationDescription[OP_ROT] = 栈顶三个项目向左轮换。
scriptOperationDescription[OP_SWAP] = 栈顶两个项目交换。
scriptOperationDescription[OP_TUCK] = 栈顶项目拷贝并且插入到栈顶倒数第二个项目之前。
scriptOperationDescription[OP_2DROP] = 删除栈顶两个项目。
scriptOperationDescription[OP_2DUP] = 复制栈顶两个项目。
scriptOperationDescription[OP_3DUP] = 复制栈顶三个项目。
scriptOperationDescription[OP_2OVER] = 拷贝栈顶两个之前的一对项目到前面。
scriptOperationDescription[OP_2ROT] = 倒数5和6项目移到栈顶。
scriptOperationDescription[OP_2SWAP] = 交换栈顶两对项目。

# Splice
scriptOperationDescription[OP_CAT] = 链接连个字符串。未激活的。
scriptOperationDescription[OP_SUBSTR] = 返回子字符串。未激活的。
scriptOperationDescription[OP_LEFT] = 保留特定点左边字符串。未激活的。
scriptOperationDescription[OP_RIGHT] = 保留特定点右边字符串。未激活的。
scriptOperationDescription[OP_SIZE] = 压栈栈顶元素字符串长度（不弹出）。

# Bitwise logic
scriptOperationDescription[OP_INVERT] = 翻转输入的所有位。未激活的。
scriptOperationDescription[OP_AND] = 输入所有位的逻辑与操作。未激活的。
scriptOperationDescription[OP_OR] = 输入所有位的逻辑或操作。未激活的。
scriptOperationDescription[OP_XOR] = 输入所有位的逻辑异或或操作。未激活的。
scriptOperationDescription[OP_EQUAL] = 如果输入相等返回1，否则返回0。
scriptOperationDescription[OP_EQUALVERIFY] = 如果输入相等返回1，否则返回0。然后执行 OP_VERIFY。（OP_VERIFY：如果栈顶值不为真则标记交易为无效）

# Arithmetic
scriptOperationDescription[OP_1ADD] = 输入加1。
scriptOperationDescription[OP_1SUB] = 输入减1。
scriptOperationDescription[OP_2MUL] = 输入乘以 2。未激活的。
scriptOperationDescription[OP_2DIV] = 输入除以 2。未激活的。
scriptOperationDescription[OP_NEGATE] = 输入符号被翻转。
scriptOperationDescription[OP_ABS] = 使得输入为正的值。
scriptOperationDescription[OP_NOT] = 如果输入是0或者1，就翻转它。否则输出是0.
scriptOperationDescription[OP_0NOTEQUAL] = 如果输入是0，则返回0，否则返回1。
scriptOperationDescription[OP_ADD] = a 加 b。
scriptOperationDescription[OP_SUB] = a 减 b。
scriptOperationDescription[OP_MUL] = a 乘以 b。未激活的。
scriptOperationDescription[OP_DIV] = a 除以 b。未激活的。
scriptOperationDescription[OP_MOD] = 返回 a 除以 b 的余数。未激活的。
scriptOperationDescription[OP_LSHIFT] = a 左移 b 位，保持符号。未激活的。
scriptOperationDescription[OP_RSHIFT] = a 右移 b 位，保持符号。未激活的。
scriptOperationDescription[OP_BOOLAND] = 如果 a 和 b 都不是0，返回1。否则返回0。
scriptOperationDescription[OP_BOOLOR] = 如果 a 或 b 不是0 返回1。否则返回0。
scriptOperationDescription[OP_NUMEQUAL] = 如果数字相等返回1，否则返回0。
scriptOperationDescription[OP_NUMEQUALVERIFY] = 与 OP_NUMEQUAL 相同，但是后续执行 OP_VERIFY。
scriptOperationDescription[OP_NUMNOTEQUAL] = 如果数字不相等返回1，否则返回0。
scriptOperationDescription[OP_LESSTHAN] = 如果a 小于 b 返回1，否则返回0。
scriptOperationDescription[OP_GREATERTHAN] = 如果a 大于 b 返回1，否则返回0。
scriptOperationDescription[OP_LESSTHANOREQUAL] = 如果a 小于或等于 b 返回1，否则返回0。
scriptOperationDescription[OP_GREATERTHANOREQUAL] = 如果a 大于或等于 b 返回1，否则返回0。
scriptOperationDescription[OP_MIN] = 返回a与b中的较小值。
scriptOperationDescription[OP_MAX] = 返回a与b中的较大值。
scriptOperationDescription[OP_WITHIN] = 如果 x 在制定范围（包含左值）则返回 1，否则返回0。

# Crypto
scriptOperationDescription[OP_RIPEMD160] = 栈顶使用RIPEMD-160哈希。
scriptOperationDescription[OP_SHA1] = 栈顶使用SHA-1哈希。
scriptOperationDescription[OP_SHA256] = 栈顶使用SHA-256哈希。
scriptOperationDescription[OP_HASH160] = 栈顶值被哈希两次：先用SHA-256，然后RIPEMD-160。
scriptOperationDescription[OP_HASH256] = 栈顶值用SHA-256哈希两次。
scriptOperationDescription[OP_CODESEPARATOR] = 签名检查将仅仅匹配最近执行OP_CODESEPARATOR之后的所有数据的签名。
scriptOperationDescription[OP_CHECKSIG] = 哈希整个交易的输出、输入和脚本（从最近执行OP_CODESEPARATOR到结束）。OP_CHECKSIG的签名必须当前哈希和公钥正确的。如果是返回1，否则返回0。
scriptOperationDescription[OP_CHECKSIGVERIFY] = 哈希整个交易的输出、输入和脚本（从最近执行OP_CODESEPARATOR到结束）。OP_CHECKSIG的签名必须当前哈希和公钥正确的。如果是返回1，否则返回0。然后执行OP_VERIFY （OP_VERIFY：如果栈顶值不为真则标记交易为无效）
scriptOperationDescription[OP_CHECKMULTISIG] = 比较第一个签名和每一个公钥，直到找到一个ECDSA匹配。从公钥序列开始，比较第二个签名与剩下的公钥，直到找到一个ECDSA匹配。重复以上过程，直到所有签名被检查或者没有足够的公钥可以找到成功的结果。所有的签名必须匹配一个公钥。如果签名比较失败，公钥将不能再次使用。scriptSig里的签名必须使用和scriptPubKey 或者 redeemScript里相应的公钥相同的顺序。如果所有签名是有效的，返回1，否则返回0.由于一个bug，栈顶的一个额外的未使用的值被删除。
scriptOperationDescription[OP_CHECKMULTISIGVERIFY] = 与 OP_CHECKMULTISIG 相同，但是后续执行 OP_VERIFY 。

# Pseudo words
scriptOperationDescription[OP_PUBKEYHASH] = 表示使用OP_HASH160来计算公钥的哈希。
scriptOperationDescription[OP_PUBKEY] = 表示公钥兼容 OP_CHECKSIG。
scriptOperationDescription[OP_INVALIDOPCODE] = 匹配任意没有指派的操作代码。

# Reserved words
scriptOperationDescription[OP_RESERVED] = 交易无效除非发生未执行的 OP_IF 分支
scriptOperationDescription[OP_VER] = 交易无效除非发生未执行的 OP_IF 分支
scriptOperationDescription[OP_VERIF] = 交易无效即使发生未执行的 OP_IF 分支
scriptOperationDescription[OP_VERNOTIF] = 交易无效即使发生未执行的 OP_IF 分支
scriptOperationDescription[OP_RESERVED1] = 交易无效除非发生未执行的 OP_IF 分支
scriptOperationDescription[OP_RESERVED2] = 交易无效除非发生未执行的 OP_IF 分支
scriptOperationDescription[OP_NOP1] = 消息被忽略。不把交易标志为无效。
scriptOperationDescription[OP_NOP2] = 消息被忽略。不把交易标志为无效。
scriptOperationDescription[OP_NOP3] = 消息被忽略。不把交易标志为无效。
scriptOperationDescription[OP_NOP4] = 消息被忽略。不把交易标志为无效。
scriptOperationDescription[OP_NOP5] = 消息被忽略。不把交易标志为无效。
scriptOperationDescription[OP_NOP6] = 消息被忽略。不把交易标志为无效。
scriptOperationDescription[OP_NOP7] = 消息被忽略。不把交易标志为无效。
scriptOperationDescription[OP_NOP8] = 消息被忽略。不把交易标志为无效。
scriptOperationDescription[OP_NOP9] = 消息被忽略。不把交易标志为无效。
scriptOperationDescription[OP_NOP10] = 消息被忽略。不把交易标志为无效。

scriptOperationDescription[ERROR] = 无法分析的脚本字节。
